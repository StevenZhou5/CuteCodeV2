# 319. 灯泡开关
# 初始时有 n 个灯泡处于关闭状态。第一轮，你将会打开所有灯泡。接下来的第二轮，你将会每两个灯泡关闭一个。
#
# 第三轮，你每三个灯泡就切换一个灯泡的开关（即，打开变关闭，关闭变打开）。第 i 轮，你每 i 个灯泡就切换一个灯泡的开关。直到第 n 轮，你只需要切换最后一个灯泡的开关。
#
# 找出并返回 n 轮后有多少个亮着的灯泡。
#
#
#
# 示例 1：
#
#
#
# 输入：n = 3
# 输出：1
# 解释：
# 初始时, 灯泡状态 [关闭, 关闭, 关闭].
# 第一轮后, 灯泡状态 [开启, 开启, 开启].
# 第二轮后, 灯泡状态 [开启, 关闭, 开启].
# 第三轮后, 灯泡状态 [开启, 关闭, 关闭].
#
# 你应该返回 1，因为只有一个灯泡还亮着。
# 示例 2：
#
# 输入：n = 0
# 输出：0
# 示例 3：
#
# 输入：n = 1
# 输出：1
#
#
# 提示：
#
# 0 <= n <= 109
class Solution():
    def get_light_cnt(self, n):
        # 灯初始状态为灭，如果最后操作被操作奇数次则会亮，被操作偶数次则会灭
        # 假设位置i = 5,那么他会在第一次和第五次的时候被操作，1和5均为i的公约数；
        # 如果i=6的话，第1，6，2,3都会被操作：其中1*6 = 6； 2*3=6;都在在6公约时被操作的
        # 假设x是i的一个公约数，那么 i/x 一定是i的另外一个公约数，只有x = i/x 时i才会被操作奇数次，i才可能最终会亮；即i = x*x 即 i为完全平方数；
        # 完全平方数：1，4，，9，16，25，36
        # 小于i的完全平方数的个数为：int(sqrt(i+0.5))，为了防止精度问题导致的计算错误 给i+0.5

        return int((n + 0.5) ** 0.5)  # 为了防止精度问题导致的计算错误 给i+0.5


solu = Solution()
print("res:", solu.get_light_cnt(109))
