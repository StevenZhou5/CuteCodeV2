# 36. 有效的数独
# 请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。
#
# 数字 1-9 在每一行只能出现一次。
# 数字 1-9 在每一列只能出现一次。
# 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）
#
#
# 注意：
#
# 一个有效的数独（部分已被填充）不一定是可解的。
# 只需要根据以上规则，验证已经填入的数字是否有效即可。
# 空白格用 '.' 表示。
#
#
# 示例 1：
#
#
# 输入：board =
# [["5","3",".",".","7",".",".",".","."]
#     ,["6",".",".","1","9","5",".",".","."]
#     ,[".","9","8",".",".",".",".","6","."]
#     ,["8",".",".",".","6",".",".",".","3"]
#     ,["4",".",".","8",".","3",".",".","1"]
#     ,["7",".",".",".","2",".",".",".","6"]
#     ,[".","6",".",".",".",".","2","8","."]
#     ,[".",".",".","4","1","9",".",".","5"]
#     ,[".",".",".",".","8",".",".","7","9"]]
# 输出：true
# 示例 2：
#
# 输入：board =
# [["8","3",".",".","7",".",".",".","."]
#     ,["6",".",".","1","9","5",".",".","."]
#     ,[".","9","8",".",".",".",".","6","."]
#     ,["8",".",".",".","6",".",".",".","3"]
#     ,["4",".",".","8",".","3",".",".","1"]
#     ,["7",".",".",".","2",".",".",".","6"]
#     ,[".","6",".",".",".",".","2","8","."]
#     ,[".",".",".","4","1","9",".",".","5"]
#     ,[".",".",".",".","8",".",".","7","9"]]
# 输出：false
# 解释：除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
#
#
# 提示：
#
# board.length == 9
# board[i].length == 9
# board[i][j] 是一位数字（1-9）或者 '.'

class Solution:
    def isValidSudoku(self, board: [[str]]) -> bool:
        # 位远算 + 状态压缩 ： 时间复杂度O(1), 空间复杂度O(1)
        row_states = [0] * 9
        col_states = [0] * 9
        matrix_states = [0] * 9

        for row in range(9):
            for col in range(9):
                if board[row][col] == ".":
                    continue
                cur_num = int(board[row][col])
                matrix_idx = (row // 3) * 3 + col // 3  # 这个比较关键，用来算9宫格的位置
                # print(cur_num, matrix_idx)
                # 二进制判断核心：判断每个num对应的二进制位是否已经有值了，如果3个规则中任意一个有了，说明已经不合法了，返回False
                if (row_states[row] >> cur_num) & 1 or (col_states[col] >> cur_num) & 1 or (
                        matrix_states[matrix_idx] >> cur_num) & 1:
                    return False
                cur_state = 1 << cur_num
                row_states[row] |= cur_state
                col_states[col] |= cur_state
                matrix_states[matrix_idx] |= cur_state

        return True
